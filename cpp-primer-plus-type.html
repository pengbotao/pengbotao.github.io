<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>C++学习笔记 – 数据类型 - 老彭的博客</title>
    <link rel="stylesheet" href="/static/css/markdown.css">
    <script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0f0111c99240380ee020030f3be990f5";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    </script>
</head>
<body>
<h1 style="font-weight:400;width:90%;margin-bottom:0px;border:0px;">C++学习笔记 – 数据类型</h1>
<a href="http://itopic.org/"><img src="/static/img/arrow-back.png" style="width:25px;height:25px;float:right;margin-top:-30px;" /></a>

<h1>基本类型</h1>

<p><code>C++</code>的基本类型分为两种：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。</p>

<h2>整型</h2>

<p>整形可分为：<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code> ，每一种都有有符号和无符号两种。<code>char</code>是一种整形，可以表示计算机中的所有的基本符号，用一个字节表示。需注意越界。其中<code>short</code>为<code>short int</code>的简称，<code>long</code>为<code>long int</code>的简称。</p>

<p><strong>C++的整形标准</strong></p>

<ul>
<li>short至少16位；</li>
<li>int至少和short一样长；</li>
<li>long至少32位，且至少和int一样长；</li>

<li><p>long long至少64位，且至少与long一样长。</p></li>

<li><p>8位的char取值范围为 -128 ~ 127，无符号为 0 ~ 255</p></li>

<li><p>16位的int取值范围为 -32768 ~ +32767，无符号为 0 ~ 65535</p></li>

<li><p>32位的int取值范围为 -2147483648 ~ +2147483647，无符号为 0~4294967295</p></li>

<li><p>64位的int取值范围为 -9223372036854775808 ~ +9223372036854775807，无符号为 0 ~ 18446744073709551615</p></li>
</ul>

<h2>bool类型</h2>

<p>字面值<code>true</code>和<code>false</code>都可以通过提升类型转换为<code>int</code>类型，<code>true</code>被转换为1，<code>false</code>被转换为0。</p>

<h2>char类型</h2>

<p>专为存储字符（如字母和数字）而设计的。<code>C++</code>对字符用单引号，对字符串使用双引号。</p>

<p>八进制 042 相当于十进制34 cout &lt;&lt; dec; 十进制 42 cout &lt;&lt; oct; 十六进制 0x42 相当于十进制66，输出为16进制。</p>

<pre><code>cout &lt;&lt; hex;
cout &lt;&lt; 123456 &lt;&lt; endl;//1e240 cout &lt;&lt; 1492 &lt;&lt; endl; 
</code></pre>

<p>除非有理由存储为其他类型（如使用特殊的后缀来表示特定的类型，或者值太大，不能存储为<code>int</code>），否则c++将整形常量存储为int类型。 后缀l或L表示该整数为<code>long</code>常量，u或U表示<code>unsigned int</code>常量，ul（可采用任何一种顺序，大小写均可）表示<code>unsigned long</code></p>

<p>C++11提供了表示<code>long long</code>的后缀ll或LL，还提供了<code>unsigned long long</code>的后缀ull、Ull、uLL、ULL</p>

<h2>const限定符</h2>

<p>常量被初始化之后，其值就被固定了，编译器不允许修改常量的值。</p>

<h2>浮点数</h2>

<p>能够表示带小数部分的数字。浮点数分两部分存储：一部分表示值，另一部分用于对值进行放大或缩小。</p>

<p>3.45E6指3.45与1000000相乘的结果，E6表示10的6次方。因此3.45E6表示34560000，6称为指数，3.45成为尾数。指数为负数表示除以10的城防，如8.55E-4表示0.000855。-8.55E4表示-85500，前面的符号用于数值，指数的符号用户缩放。</p>

<p><code>float</code> 、<code>double</code> 、<code>long double</code>是按照他们可以表示的有效数位和允许的指数最小范围来描述的。有效位是数字中有意义的位。C和C++对有效位的要求是<code>float</code>至少32位<code>double</code>至少48位，且不少于<code>float</code>。<code>long double</code>至少和<code>double</code></p>

<p>通常<code>float</code>为32位，<code>double</code>为64位，<code>long double</code>为80 96或128位，另外这三种类型的指数范围为-37 ~ 37</p>

<p>后缀默认情况为都属于<code>double</code>类型，如果希望为<code>float</code>可使用f或F后缀。对于<code>long double</code>类型，可使用l或L后缀。</p>

<h1>复合类型</h1>

<p>复合类型是基于整形和浮点型创建的。影响最为深远的复合类型是类。</p>

<h2>数组</h2>

<p>数组是一种数据格式，能够存储多个同类型的值。</p>

<pre><code>typeName arrayName[arraySize]
</code></pre>

<p><code>int months[12] = {1, 2, 3};</code>其他元素将设置为0</p>

<p><code>char name[4] = {'p', 'i', 'g', '\0'};</code></p>

<p>不能将一个数组赋值给另一个数组。</p>

<h2>字符串</h2>

<p>存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。一种来自C语言，常被称为C-风格字符串，另一种基于string类库的方法。</p>

<p><strong>C-风格字符串：</strong>
以空字符 \0 结尾，其ASCII为0，用来标记字符串的结尾。</p>

<pre><code>char name[4] = {'p', 'i', 'g', '!'};//不是字符串
char name[4] = {'p', 'i', 'g', '\0'};//是字符串
</code></pre>

<p>用引号括起的字符串称为字符串常量或字符串字面值，隐式包含结尾的空字符，如：</p>

<pre><code>char bird[11] = &quot;Mr. Cheeps&quot;;
char fish[] = &quot;Bubbles&quot;;
</code></pre>

<p>strlen不计算空字符，<code>strlen(bird) == 10</code></p>

<pre><code>strcpy(charr1, charr2);//copy charr2 to charr1
strcat(charr1, charr2);//append contents of charr2 to charr1
 
strncpy(food, &quot;a picnic basket filled with many goodies&quot;, 19);
food[10] = '\0';
</code></pre>

<p><strong>cin如何确定已完成字符串的输入?</strong>
由于不能通过键盘输入空字符，因此cin需要用别的发那个发来确定字符串的结尾位置。cin使用空白、制表符和换行符来确定字符串的结束位置。</p>

<p>读取一行：<code>cin.getline()</code>和<code>cin.get()</code>。
这两个函数否读取一行输入，直到达到换行符。不同的是，<code>cin.getline()</code>将丢弃换行符，<code>get</code>将保留换行符在输入序列中。<code>cin.getline(fish, 20);</code>  <code>cin.get()</code>读取下一个字符</p>

<p><strong>string类</strong></p>

<ul>
<li>可以使用C-风格字符串来初始化string对象，如<code>string str2 = &quot;test&quot;;</code></li>
<li>可以使用cin、cout来输入或输出string对象</li>
<li>可以使用数组表示法来访问存储在string对象中的字符</li>
</ul>

<p>可以将一个string对象赋值给另一个string对象，string类与C-风格字符串</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
 
using namespace std;
 
void main()
{
    char char1[20];
    char char2[20] = &quot;c string&quot;;
 
    string str1;
    string str2 = &quot;string&quot;;
 
    str1 = str2;
    strcpy(char1, char2);
 
    str1 += &quot; !&quot;;
    strcat(char1, &quot; !&quot;);
     
    int len1 = strlen(char1);
    int len2 = str1.size();
    cout &lt;&lt; char1 &lt;&lt; endl &lt;&lt; str1 &lt;&lt; endl;
}
</code></pre>

<p>string类读取一行 <code>getline(cin, str)</code>;</p>

<h2>结构和结构数组</h2>

<pre><code>struct sname
{
    int id;
    char name[20];
 
};
void main()
{
    sname s[1];
    s[0].id = 1;
    strcpy(s[0].name, &quot;pig&quot;);
 
    cout &lt;&lt; s[0].id &lt;&lt; &quot;:&quot; &lt;&lt; s[0].name &lt;&lt; endl;
}
</code></pre>

<h2>共用体</h2>

<p>共用体能存储不同的数据类型，但只能同时存储其中的一种类型。</p>

<h2>枚举</h2>

<pre><code>enum 枚举名{
    标识符[=整型常数],
    标识符[=整型常数],

    ...
    标识符[=整型常数],
} 枚举变量;
enum spectrum{red = 1, orange, yellow, green, blue};
</code></pre>

<p>只能将整型赋值给枚举。</p>

<h2>指针 - 变量的地址</h2>

<p>OOP强调的是在运行阶段（而不是编译阶段）进行决策。</p>

<p><strong>指针：</strong>用于存储值的地址。*运算符被成为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。</p>

<pre><code>int * id;
char *pc = new char;
</code></pre>

<p>通常情况下，地址需要2个还是4个字节取决于计算机系统。一定要在对指针应用解除引用运算符之前，将指针初始化一个确定的、适当的地址。</p>

<p>C语言可通过<code>malloc</code>来分配内存；在C++中仍然可以这样做，但C++还有更好的方法 - <code>new</code>运算符。</p>

<p>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下：</p>

<pre><code>typeName * pointer_name = new typeName;
</code></pre>

<p>new分配的内存块通常与常规变量声明分配的内存块不同。常规变量存储在栈中，而new存储在堆或自由存储区的内存区域中。
使用<code>new</code>分配的内存需要使用<code>delete</code>来释放，一定要配对使用<code>new</code>和<code>delete</code>，否则将发生内存泄漏，也就是说，被分配的内存再也无法使用了。如果使用<code>new</code>时带方括号，则<code>delete</code>也应带上，如果没带，则不用带。</p>

<p><strong>new和delte遵守规则</strong></p>

<ul>
<li>不要使用delete来释放不是new分配的内存</li>
<li>不要使用delete释放同一个内存卡两次</li>
<li>如果使用new [] 为数组分配内存，则应使用delete []来释放</li>
<li>如果使用new为一个实体分配内存，则应使用delete来释放</li>
<li>对空指针应用delete是安全的。</li>
</ul>

<p>在编译时给数组分配内存称为静态联编，在运行时动态分配称为动态联编。</p>

<p><strong>使用new创建动态数组</strong>
为数组分配内存的通过格式</p>

<pre><code>typeName * pointer_name = new typeName[num_elements];
</code></pre>

<pre><code>int * psome = new int[10];
delete [] psome;
</code></pre>

<p><strong>使用动态数组</strong>
指针指向内存块中的第一个元素，所以<code>*psome</code>是第一个元素的值。也可使用数组的方式来访问，如<code>psome[2]</code>。数组与指针基本等价是C和C++的优点之一</p>

<p><strong>C++将数组名解释为地址</strong>
指针变量加1后，增加的量等于它指向的类型的字节数。</p>

<p>对数组使用sizeof运算符得到的是数组的长度，而指针使用sizeof得到的是指针的长度，即使指针指向的是一个数组。</p>

<p>数组名被解释为第一个元素的地址，对数组名应用地址符时，得到的是整个数组的地址。</p>

<pre><code>short tell[10];
cout &lt;&lt; tell &lt;&lt; endl;
cout &lt;&lt; &amp;tell &lt;&lt; endl;
</code></pre>

<p>从数字上说，这两个地址相同。但从概率上说，&amp;tell[0]是一个2字节内存块的地址，而&amp;tell是以一个20字节的内存块的地址。因此，表达式tell+1将地址值增加2，而&amp;tell+2将地址加20.</p>

<p>如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符(-&gt;)</p>

<p>自动存储、静态存储和动态存储</p>

<h2>数组的替代品</h2>

<p><strong>模板类<code>vector</code></strong></p>

<pre><code>vector&lt;typeName&gt; vt(n_elem);
</code></pre>

<p>n_elem可以是整形常量，也可以是整形变量</p>

<p><strong>模版类<code>array</code></strong></p>

<pre><code>array&lt;typeName, n_elem&gt; arr;
</code></pre>

<p>与创建<code>vector</code>不同，<code>n_elem</code>不能是变量</p>

<p>数组、<code>vector</code>、<code>array</code>都可使用标准数组表示法来访问各个元素。</p>

<div style="padding: 0 10px;float:left;margin-bottom:20px;color:#aaa;">-- EOF --</div>
<div style="float:right;">
    <a href="http://itopic.org/"><img src="/static/img/arrow-back.png" style="width:25px;height:25px;" /></a>
</div>
<div style="padding: 0 10px;text-align:right;float:right;">
    发表于：
    <code style="border:0px;background:none;"><a href="/2015-03.html">2015-03-26 21:05</a></code>
</div>
<div style="padding: 0 10px;text-align:right;float:right;">
    标签：
    <code style="border:0px;background:none;"><a href="/tag/c++.html">C++</a></code>
    <code style="border:0px;background:none;"><a href="/tag/学习笔记.html">学习笔记</a></code>
</div>

<BR>

<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script>
  var cloudTieConfig = {
    url: document.location.href, 
    sourceId: "cpp-primer-plus-type",
    productKey: "47a1277aece74470855c0e74c1208eaf",
    target: "cloud-tie-wrapper"
  };
</script>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>

<div id="top"><a href="#"><img src="/static/img/arrow-top.png" style="width:40px;height:40px;" /></a></div>
</body>
</html>
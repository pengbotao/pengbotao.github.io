<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Python入门知识点整理</title>
    <link rel="stylesheet" href="/static/css/markdown.css">
    <style type="text/css">
    @media (min-width: 1200px) {
        .content{padding-left:280px;width:100%;max-width:100%;}
    }
    </style>
</head>
<body>
<div class="content">
    <h1 class="title">Python入门知识点整理</h1>

    <a href="/"><img src="/static/img/arrow-back.png" class="title_arrow_back" /></a>

    <nav>
<ul>
<li><a href="#一-数据类型">一、数据类型</a>
<ul>
<li><a href="#1-1-数值类型-number">1.1 数值类型 - Number</a></li>
<li><a href="#1-2-字符串-str">1.2 字符串 - str</a></li>
<li><a href="#1-3-字符串常用操作">1.3 字符串常用操作</a></li>
</ul></li>
<li><a href="#二-控制流">二、控制流</a>
<ul>
<li><a href="#2-1-if语句">2.1 if语句</a></li>
<li><a href="#2-2-while语句">2.2 while语句</a></li>
<li><a href="#2-3-for语句">2.3 for语句</a></li>
</ul></li>
<li><a href="#三-数据结构">三、数据结构</a>
<ul>
<li><a href="#3-1-列表-list">3.1 列表 - list</a></li>
<li><a href="#3-2-元祖-tuple">3.2 元祖 - tuple</a></li>
<li><a href="#3-3-字典-dict">3.3 字典 - dict</a></li>
<li><a href="#3-4-集合-set">3.4 集合 - set</a></li>
</ul></li>
<li><a href="#四-类型总结">四、类型总结</a>
<ul>
<li><a href="#4-1-类型对比">4.1 类型对比</a></li>
<li><a href="#4-2-类型转换">4.2 类型转换</a></li>
</ul></li>
<li><a href="#五-函数">五、函数</a>
<ul>
<li><a href="#5-1-函数定义">5.1 函数定义</a></li>
<li><a href="#5-2-函数参数">5.2 函数参数</a></li>
<li><a href="#5-3-函数返回">5.3 函数返回</a></li>
<li><a href="#5-4-函数调用">5.4 函数调用</a></li>
</ul></li>
<li><a href="#六-类-class">六、类 - Class</a>
<ul>
<li><a href="#6-1-类定义">6.1 类定义</a></li>
<li><a href="#6-2-访问限制">6.2 访问限制</a></li>
<li><a href="#6-3-成员属性">6.3 成员属性</a></li>
<li><a href="#6-4-成员方法">6.4 成员方法</a></li>
</ul></li>
<li><a href="#七-错误和异常">七、错误和异常</a></li>
<li><a href="#八-高级用法">八、高级用法</a>
<ul>
<li><a href="#8-1-三元表达式">8.1 三元表达式</a></li>
<li><a href="#8-2-推导式">8.2. 推导式</a></li>
<li><a href="#8-3-map-fliter-reduce函数">8.3 map &amp;&amp; fliter &amp;&amp; reduce函数</a></li>
<li><a href="#8-4-sort-sorted">8.4 sort &amp;&amp; sorted</a></li>
<li><a href="#8-5-zip函数">8.5 zip函数</a></li>
</ul></li>
</ul>
</nav>

<h1 id="一-数据类型">一、数据类型</h1>

<h2 id="1-1-数值类型-number">1.1 数值类型 - Number</h2>

<ul>
<li>int（有符号整型）</li>
<li>long（长整型，Python3去掉）</li>
<li>float（浮点数）</li>
<li>complex（复数）</li>
</ul>

<h2 id="1-2-字符串-str">1.2 字符串 - str</h2>

<p>可以使用单引号或者双引号来创建字符串，如：</p>

<pre><code>&gt;&gt;&gt; a = &quot;Hello World&quot;
&gt;&gt;&gt; b = 'iTopic.org'
</code></pre>

<h2 id="1-3-字符串常用操作">1.3 字符串常用操作</h2>

<p><strong>1. 字符串格式化</strong></p>

<pre><code># 字符串拼接
&gt;&gt;&gt; &quot;Hello world &quot; + &quot;2019&quot;
'Hello world 2019'
# 字符串包含变量
&gt;&gt;&gt; &quot;Hello %s %d&quot; % (&quot;world&quot;, 2019)
'Hello world 2019'
# 字符串占位符
&gt;&gt;&gt; &quot;Hello {0} {1}&quot;.format(&quot;world&quot;, 2019)
'Hello world 2019'
# 字符串拼接
&gt;&gt;&gt; ' '.join([&quot;Hello world&quot;, &quot;2019&quot;])
'Hello world 2019'
</code></pre>

<p><strong>2. 字符串去掉两侧空白字符</strong></p>

<pre><code>&gt;&gt;&gt; s = &quot;Hello world 2019 &quot;
# 去掉两侧字符
&gt;&gt;&gt; s.strip()
'Hello world 2019'
# 去掉左侧字符
&gt;&gt;&gt; s.lstrip(&quot;H&quot;)
'ello world 2019 '
# 去掉右侧字符
&gt;&gt;&gt; s.rstrip(&quot; 2019 &quot;)
'Hello world'
</code></pre>

<p><strong>3. 字符串分隔</strong></p>

<pre><code># 字符串分隔
&gt;&gt;&gt; fruits = &quot;apple, orange, banana&quot;
&gt;&gt;&gt; fruits.split(&quot;, &quot;)
['apple', 'orange', 'banana']

# 字符串拼接
&gt;&gt;&gt; &quot;-&quot;.join([&quot;Hello&quot;, &quot;World&quot;])
'Hello-World'
</code></pre>

<p><strong>4. 字符串替换</strong></p>

<pre><code>&gt;&gt;&gt; s = &quot;Hello 2019.&quot;
&gt;&gt;&gt; s.replace(&quot;2019&quot;, &quot;2020&quot;)
'Hello 2020.'
</code></pre>

<p><strong>5. 判断前缀、后缀</strong></p>

<pre><code># 判断前缀
&gt;&gt;&gt; s = &quot;Hello 2019.&quot;
&gt;&gt;&gt; s.startswith(&quot;Hello&quot;)
True

# 判断后缀
&gt;&gt;&gt; s.endswith(&quot;.&quot;)
True
&gt;&gt;&gt; s.endswith(&quot;2019&quot;)
False
</code></pre>

<p><strong>6. 字符串比较</strong></p>

<pre><code># 内置函数cmp比较
&gt;&gt;&gt; a = &quot;Hello&quot;
&gt;&gt;&gt; b = &quot;hello&quot;
&gt;&gt;&gt; cmp(a, b)
-1
</code></pre>

<p>上面已列出一些字符串函数的使用，关于更多模块的文档可按如下方式进行查看。<strong>Python中文档查看方法：</strong></p>

<ol>
<li><p>命令行中可以通过<code>dir(str)</code>查看字符串支持的方法：</p>

<pre><code>&gt;&gt;&gt; dir(str)
['...', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find',
'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper',
'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust',
'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']
</code></pre></li>

<li><p>查看对应函数的说明文档：</p></li>
</ol>

<pre><code>&gt;&gt;&gt; print(str.find.__doc__)
S.find(sub [,start [,end]]) -&gt; int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.

&gt;&gt;&gt; help(str.join)
</code></pre>

<ol>
<li>Web服务</li>
</ol>

<pre><code>python -m pydoc -p 8899
</code></pre>

<h1 id="二-控制流">二、控制流</h1>

<h2 id="2-1-if语句">2.1 if语句</h2>

<pre><code>fruits = &quot;apple&quot;

if fruits == &quot;apple&quot;:
    print(&quot;it's an apple&quot;)
elif fruits == &quot;orange&quot;:
    print(&quot;it's an orange&quot;)
else:
    print(&quot;other&quot;)
</code></pre>

<p><code>Python</code>不支持<code>switch</code>语句。</p>

<h2 id="2-2-while语句">2.2 while语句</h2>

<pre><code>i = 0
while i &lt; 10:
    print(i)
    i += 2
    # break
else:
    print(&quot;else i = %d &quot; % i)
</code></pre>

<p>Python中while语句可以带一个else语句，当循环正常结束时执行，需要注意通过break结束的循环不会执行else语句。</p>

<h2 id="2-3-for语句">2.3 for语句</h2>

<pre><code>for i in range(0, 10, 1):
    print(i)
</code></pre>

<p>示例中range可以理解成<code>(i = 0; i &lt;10; i++)</code>，同时可以精简写成<code>rang(10)</code>, 等同于区间<code>[0, 10)</code>的数组.</p>

<p><code>for</code>语句后同样可以带<code>else</code>语句，使用和<code>while</code>里一致。</p>

<hr />

<p>可以看到控制语句后面都可以携带<code>else</code>语句。有一种查找的用法，</p>

<pre><code>import random

m = random.randint(5, 15)

for i in range(10):
    if i == m:
        print(&quot;find %d&quot; % m)
        break
else:
    print(&quot;can't find %d&quot; % m)
</code></pre>

<h1 id="三-数据结构">三、数据结构</h1>

<h2 id="3-1-列表-list">3.1 列表 - list</h2>

<ul>
<li>列表有序，是一种序列</li>
<li>列表可变长度，可通过<code>list</code>的相关操作对列表进行增删等操作</li>
<li>列表数据类型可不同，即并不要求所有列表元素都是同一数据类型</li>
<li>列表用中括号表示</li>
</ul>

<p><strong>列表提供的方法列表</strong>
(通过<code>dir(list)</code>可查看到)</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>list.append(obj)</code></td>
<td>在列表末尾添加新的对象</td>
</tr>

<tr>
<td><code>list.count(obj)</code></td>
<td>统计某个元素在列表中出现的次数</td>
</tr>

<tr>
<td><code>list.extend(seq)</code></td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>

<tr>
<td><code>list.index(obj)</code></td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>

<tr>
<td><code>list.insert(index, obj)</code></td>
<td>将对象插入列表</td>
</tr>

<tr>
<td><code>list.pop(obj=list[-1])</code></td>
<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>

<tr>
<td><code>list.remove(obj)</code></td>
<td>移除列表中某个值的第一个匹配项</td>
</tr>

<tr>
<td><code>list.reverse()</code></td>
<td>反向列表中元素</td>
</tr>

<tr>
<td><code>list.sort([func])</code></td>
<td>对原列表进行排序</td>
</tr>
</tbody>
</table>

<p><strong>1. 列表初始化及遍历</strong></p>

<pre><code># 初始化列表
fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]

# 默认遍历列表。默认只有一个参数接收遍历的值。用于按`{VAL}`遍历。该参数标识列表的值。
for val in fruits:
    print(val)

# 根据长度来遍历。用于按`{KEY}`遍历
for idx in range(len(fruits)):
    print(fruits[idx])

# 按索引 - 值遍历，也可用于字典。用于按`{KEY - VAL}`遍历
for idx, val in enumerate(fruits):
    print(idx, val)
</code></pre>

<p><strong>2. 合并数据</strong></p>

<pre><code># 直接在原列表后面追加数据。可以是任何类型。
fruits.append(&quot;pear&quot;)
print(fruits) # output: ['apple', 'orange', 'banana', 'grape', 'pear']

# 在list后扩展数据，接收一个list，展平的方式追加到原列表后面
fruits.extend([&quot;peach&quot;, &quot;strawberry&quot;])
print(fruits) # output: ['apple', 'orange', 'banana', 'grape', 'pear', 'peach', 'strawberry']

# 也可用加号来合并两个列表
fruits + [&quot;mango&quot;] # mango追加到fruits数据后面

# 删除数据的3中方法
fruits.pop(2)
furits.remove(&quot;banana&quot;)
del fruits[2]
</code></pre>

<p><strong>3. 健壮性判断</strong></p>

<pre><code># 判断值是否在列表中(in 与 not in)
if &quot;strawberry&quot; in fruits:
    print(&quot;strawberry is in frutis&quot;) # output: strawberry is in frutis
else:
    print(&quot;strawberry is not in frutis&quot;)

# 类型判断
if isinstance(fruits, list):
    print(&quot;fruits is a list&quot;)

# 强制类型转换
&gt;&gt;&gt; x = &quot;Hello Python&quot;
&gt;&gt;&gt; list(x)
['H', 'e', 'l', 'l', 'o', ' ', 'P', 'y', 't', 'h', 'o', 'n']

# 判断是否为空
if not fruits:
    print(&quot;fruits is empty&quot;)

if len(fruits) == 0:
    print(fruits is empty)
</code></pre>

<h2 id="3-2-元祖-tuple">3.2 元祖 - tuple</h2>

<ul>
<li>元祖有序，也是一种序列</li>
<li>元祖一旦初始化不可修改</li>
<li>元祖数据类型也可不同</li>
<li>元祖用圆括号表示</li>
<li>元祖的访问和遍历同列表</li>
</ul>

<p><strong>元祖提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>tuple.count(obj)</code></td>
<td>统计某个元素在元祖中出现的次数</td>
</tr>

<tr>
<td><code>tuple.index(obj)</code></td>
<td>从元祖中找出某个值第一个匹配项的索引位置</td>
</tr>
</tbody>
</table>

<p><strong>1. 元祖初始化</strong></p>

<pre><code># 初始化元祖。只有1个元素时最后携带逗号
fruits = (&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;)

# 和列表一致，按索引的方式进行访问
print(fruits[0])

# 遍历元祖
for val in fruits:
    print(val)
</code></pre>

<h2 id="3-3-字典-dict">3.3 字典 - dict</h2>

<ul>
<li>按<code>键-值</code>对的方式初始化，相同的键会覆盖，用大括号表示</li>
<li>字典无序</li>
</ul>

<p><strong>字典提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>dict.clear()</code></td>
<td>清空字典</td>
</tr>

<tr>
<td><code>dict.get(k[,d])</code></td>
<td>D[k] if k in D, else d.  d defaults to None.</td>
</tr>

<tr>
<td><code>dict.items()</code></td>
<td>list of D&rsquo;s (key, value) pairs, as 2-tuples</td>
</tr>

<tr>
<td><code>dict.keys()</code></td>
<td>list of D&rsquo;s keys</td>
</tr>

<tr>
<td><code>dict.values()</code></td>
<td>list of D&rsquo;s values</td>
</tr>

<tr>
<td><code>dict.pop(k, d)</code></td>
<td>remove specified key and return the corresponding value.If key is not found, d is returned if given, otherwise KeyError is raised</td>
</tr>

<tr>
<td><code>dict.update(obj)</code></td>
<td>合并两个字典</td>
</tr>

<tr>
<td><code>dict.setdefault(k[,d])</code></td>
<td>D.get(k,d), also set D[k]=d if k not in D</td>
</tr>
</tbody>
</table>

<p><strong>1. 字典初始化及遍历</strong></p>

<pre><code># 初始化字典方式一
fruits = {&quot;apple&quot;: 1, &quot;orange&quot;: 2, &quot;banana&quot;: 3}
# 初始化字典方式二
fruits = dict(apple = 1, orange = 2, banana = 3)

# 按KEY遍历
for idx in fruits:
    print(fruits[idx])

# 判断键是否在字典中
if &quot;grape&quot; in fruits:
    print(fruits[&quot;grape&quot;])
else:
    fruits[&quot;grape&quot;] = 4
# 判断键是否在字段中
if fruits.has_key(&quot;apple&quot;):
    print(fruits[&quot;apple&quot;])

# 按KEY - VALUE遍历
for idx, val in fruits.items():
    print(idx, val)
</code></pre>

<p><strong>2. 字典操作</strong></p>

<p>批量更新字典里的内容。</p>

<pre><code>fruits = dict(apple = 1, orange = 2, banana = 3)
fruits.update(cherry = 4)
# {'orange': 2, 'cherry': 4, 'banana': 3, 'apple': 1}

fruits.update({&quot;mango&quot;: 5})
# {'orange': 2, 'cherry': 4, 'mango': 5, 'banana': 3, 'apple': 1}

fruits.keys() # ['orange', 'cherry', 'mango', 'banana', 'apple']

# 删除数据的3中方法
del fruits[&quot;apple&quot;]
fruits.pop(&quot;banana&quot;)

# 清空字典
fruits.clear()
</code></pre>

<h2 id="3-4-集合-set">3.4 集合 - set</h2>

<ul>
<li>集合里的VALUE可以是不同的类型，相同数据会<code>去重</code>。</li>
<li>集合<code>无序</code></li>
</ul>

<p><strong>集合提供的方法列表</strong></p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>set.add(obj)</code></td>
<td>往集合里添加元素</td>
</tr>

<tr>
<td><code>set.update(obj)</code></td>
<td>更新合并集合</td>
</tr>

<tr>
<td><code>set.discard(obj)</code></td>
<td>丢弃一个元素</td>
</tr>

<tr>
<td><code>set.remove(obj)</code></td>
<td>移除一个元素</td>
</tr>

<tr>
<td><code>set.pop()</code></td>
<td>从集合中弹出一个元素</td>
</tr>

<tr>
<td><code>set.clear()</code></td>
<td>清空一个集合</td>
</tr>

<tr>
<td>-</td>
<td>更多交叉并补方法</td>
</tr>
</tbody>
</table>

<p><strong>1. 集合初始化</strong></p>

<pre><code># 可变集合set初始化 - 初始化之后在进行赋值
fruits = set()
fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 直接创建
fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 通过列表转换
fruits = set([&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;])
print(fruits)

# 通过字典转换
fruits = set({&quot;apple&quot;:1, &quot;orange&quot;:2, &quot;banana&quot;:3}) # set(['orange', 'apple', 'banana'])


# 不可变集合用frozenset表示
websites = frozenset([&quot;qq.com&quot;, &quot;weibo.com&quot;])
</code></pre>

<p>集合分为可变集合(<code>set</code>)和不可变集合(<code>frozenset</code>)。针对可变集合可以往集合里<strong>添加元素</strong>。</p>

<pre><code>fruits = {&quot;apple&quot;, &quot;orange&quot;}
fruits.add(&quot;banana&quot;) # set(['orange', 'apple', 'banana'])

fruits.update({&quot;cherry&quot;}) # set(['orange', 'cherry', 'apple', 'banana'])

fruits.update(&quot;grape&quot;) # set(['a', 'e', 'apple', 'g', 'cherry', 'p', 'r', 'orange', 'banana'])

</code></pre>

<p><strong>移除元素</strong></p>

<pre><code>fruits = {&quot;apple&quot;, &quot;orange&quot;}

# 移除不存在的元素不会报错
fruits.discard(&quot;test&quot;) 

# 移除不存在的元素会报错
fruits.remove(&quot;apple&quot;) 

# 弹出一个元素，集合为空时会报错
fruits.pop()

# 清空集合
fruits.clear()
</code></pre>

<p><strong>2. 集合的交叉并补等操作</strong></p>

<pre><code>&gt;&gt;&gt; x = set([1, 2, 3])
&gt;&gt;&gt; y = set([3, 4, 5])
&gt;&gt;&gt; x &amp; y   # 交集
set([3])
&gt;&gt;&gt;
&gt;&gt;&gt; x | y   # 并集
set([1, 2, 3, 4, 5])
&gt;&gt;&gt;
&gt;&gt;&gt; x - y   # 差集
set([1, 2])
</code></pre>

<h1 id="四-类型总结">四、类型总结</h1>

<h2 id="4-1-类型对比">4.1 类型对比</h2>

<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>序列</th>
<th>可变类型</th>
<th>传引用</th>
<th>获取</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>数值类型</code></td>
<td><code>i=1</code></td>
<td>-</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>字符串</code></td>
<td><code>str=&quot;Hello&quot;</code></td>
<td>是</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>list</code></td>
<td><code>[]</code></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>索引</td>
</tr>

<tr>
<td><code>dict</code></td>
<td><code>{}</code></td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>键</td>
</tr>

<tr>
<td><code>set</code></td>
<td><code>set()</code></td>
<td>否</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>

<tr>
<td><code>tuple</code></td>
<td><code>()</code></td>
<td>是</td>
<td>否</td>
<td>-</td>
<td>索引</td>
</tr>
</tbody>
</table>

<p>列表、元组和字符串都是序列。字符串是字符的序列，列表和元祖是任意类型的序列。</p>

<p>序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。</p>

<pre><code>fruits = &quot;apple&quot;

# 索引操作
print(fruits[1])

# 切片操作
print(fruits[1:-1])
print(fruits[1:])
print(fruits[:-1])
print(fruits[:])
</code></pre>

<h2 id="4-2-类型转换">4.2 类型转换</h2>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>bool(x)</td>
<td>将x转bool类型</td>
</tr>

<tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>

<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>

<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>

<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>

<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>

<tr>
<td>set(s)</td>
<td>将序列 s 转换为一个集合</td>
</tr>
</tbody>
</table>

<h1 id="五-函数">五、函数</h1>

<h2 id="5-1-函数定义">5.1 函数定义</h2>

<p><strong>1. 常规函数</strong></p>

<p>定义一个空函数，由于没有花括号表示代码块，针对空的代码块可以用pass占位。</p>

<pre><code>def func(x, y):
    pass
</code></pre>

<p><strong>2. 匿名函数</strong></p>

<p>函数定义：<code>lambda 参数: 表达式</code></p>

<pre><code>f = lambda x, y: x*y
print(f(2, 3))
print((lambda x: x*x)(3))
</code></pre>

<p><strong>3. 闭包函数</strong></p>

<p><code>pass</code></p>

<h2 id="5-2-函数参数">5.2 函数参数</h2>

<p><code>python</code>的参数传入确实是相当的方便，参数传入非常灵活。其中可变参数和关键字参数更是无法直接明确到函数的定义，在没有文档的情况下，碰到这样的定义无法清晰知道函数的表达能力。需要借助对方的文档或者阅读代码才好了解。 这也是灵活背后带来的不好的地方。</p>

<pre><code>def func(x, y = 1, *args, **kwargs):
    print(type(args))
    print(type(kwargs))
    print(locals())

args = [1, 2]
kwargs = {&quot;param&quot;: &quot;web&quot;}

func(1, 2, 3, '4', param=&quot;web&quot;)
# &lt;type 'tuple'&gt;
# &lt;type 'dict'&gt;
# {'y': 2, 'x': 1, 'args': (3, '4'), 'kwargs': {'param': 'web'}}

func(1, 2, *args, **kwargs)
# &lt;type 'tuple'&gt;
# &lt;type 'dict'&gt;
# {'y': 2, 'x': 1, 'args': (1, 2), 'kwargs': {'param': 'web'}}
</code></pre>

<ul>
<li>Python函数支持设置默认参数</li>
<li>支持可变参数<code>*args</code>。函数接收到的数据类型是元祖。调用时可以以展平的方式传入，或者以列表、元祖的解引用的方式传入。</li>
<li>支持关键字参数<code>**kwargs</code>。函数接收到的数据类型是字典。</li>
</ul>

<h2 id="5-3-函数返回">5.3 函数返回</h2>

<p><strong>1. 多返回值</strong></p>

<pre><code>def func(x, y = 1):
    return x,y

x = func(1)

print(type(x))
print(x)

# &lt;type 'tuple'&gt;
# (1, 1)


x, _ = func(1)
print(type(x))
print(x)

# &lt;type 'int'&gt;
# 1
</code></pre>

<p><code>python</code>支持多个返回值，多个返回值实际返回的是一个元祖。多个参数时用一个参数接收时为元祖，用多个参数时可以直接将元祖解开得到具体的数据类型。</p>

<p><strong>2. 返回对象</strong></p>

<p>返回一个匿名函数。</p>

<pre><code>def func(x, y = 1):
    # lambda 参数: 表达式
    return lambda t: x+y if t == 1 else x*y

x = func(2, 3)
print(x(1))
print(type(x))

# 5
# &lt;type 'function'&gt;
</code></pre>

<h2 id="5-4-函数调用">5.4 函数调用</h2>

<p><code>python</code>中<strong>数字、字符、元组等不可变对象类型都属于值传递，而字典和列表等可变对象类型属于引用传递。</strong>对于可变对象意味着函数内部可以修改实参的值。</p>

<pre><code>import random

def func(x):
    x.append(random.randint(1, 100))
    print(x)

p = []
func(p)
func(p)
print(p)
# 打印[85, 86]，可见函数内部对p的修改直接影响了原有的值.
</code></pre>

<h1 id="六-类-class">六、类 - Class</h1>

<h2 id="6-1-类定义">6.1 类定义</h2>

<pre><code>class Test(object):

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def sum(self):
        return self.x + self.y


t = Test(1, 2)
print(t.sum())
</code></pre>

<h2 id="6-2-访问限制">6.2 访问限制</h2>

<p>Python只有公有和私有，默认公有，当属性或方法前面有两个下划线（<code>__</code>）时，就只有内部可以访问，外部就只能间接访问而无法直接访问了。</p>

<h2 id="6-3-成员属性">6.3 成员属性</h2>

<p>Python中并不需要在类中预定义属性，这样子会存在一个问题，并不太方便知道一个类有多少个成员属性。比如，在上面函数中增加一行：</p>

<pre><code>    def sum(self):
        self.z = self.x + self.y
        return self.x + self.y
</code></pre>

<p>这样子在调用<code>sum</code>方法之后打印类对象：<code>print(vars(t))</code>，可以看到结果：<code>{'y': 2, 'x': 1, 'z': 3}</code>。这种不确定性在程序维护过程中会比较麻烦。所以对通用的属性可以考虑在构造函数<code>__init__</code>中做一个初始化，方便知道类中有哪些可使用的属性。</p>

<p>对属性的设置除了常规的用法外，也可以通过<code>@property</code>装饰器做一些限制。比如设置只读，对设置的值做一些检测。</p>

<pre><code>
class Test(object):

    def __init__(self):
        self._age = 18

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise ValueError(&quot;age must be int.&quot;)
        self._age = value


t = Test()
print(t.age)
t.age = 20
print(t.age)
#设置非int会抛异常
#t.age = &quot;123&quot;
</code></pre>

<ul>
<li>可以直接通过<code>示例.属性名</code>来获取，不需要带函数的括号。</li>
<li>不设置对应的<code>setter</code>方法时，该属性对外只读，修改会抛异常。</li>
</ul>

<h2 id="6-4-成员方法">6.4 成员方法</h2>

<p>成员方法有3中形式：实例方法、类方法、静态方法。</p>

<ul>
<li>实例方法：需要显示的传入self对象参数，需要实例化类之后调用方法</li>
<li>类方法(<code>@classmethod</code>)：不需要实例化类，方法属于类</li>
<li>静态方法(<code>@staticmethod</code>): 相当于放在类里面的函数，从功能上看属于类，但不需要调用类里其他的成员属性和成员方法。</li>
</ul>

<p>定义方式如下：</p>

<pre><code>class Test(object):

    __n = 0

    @classmethod
    def show(cls):
        print(&quot;Hello World {0}&quot;.format(cls.__n))

    @staticmethod
    def sum(x, y):
        return x + y


Test.sum(1, 2)
Test.show()
</code></pre>

<h1 id="七-错误和异常">七、错误和异常</h1>

<pre><code>try:
    t = Test(1, 'b')
    print(t.sum())
except (TypeError, NameError) as err:
    print(err)
except Exception as e:
    print(e)
else:
    raise Exception(&quot;throw exception&quot;)
</code></pre>

<h1 id="八-高级用法">八、高级用法</h1>

<h2 id="8-1-三元表达式">8.1 三元表达式</h2>

<p><code>[on true] if [expression] else [on false]</code></p>

<p>等价于：</p>

<pre><code>if [expression]:
    [on true]
else:
    [on false]
</code></pre>

<p>示例：</p>

<pre><code>$ import random

$ x = True if random.randint(0, 10) &gt; 5 else False
</code></pre>

<h2 id="8-2-推导式">8.2. 推导式</h2>

<p>下面是一个列表推导式，用来快速创建一个列表。可以分为列表推导式，字典推导式和集合推导式。</p>

<pre><code>[ expression for x in X [if condition]
             for y in Y [if condition]
             ...
             for n in N [if condition] ]
</code></pre>

<p>相当于：</p>

<pre><code>L = []
for x i X:
    [if condition]:
        for y in Y:
            [if condition]:
                L.append(x, y)

</code></pre>

<p>示例：</p>

<pre><code># 列表推导式
$ L = [x*y for x in range(1, 5) for y in range(6, 10) if y &gt; 8]
# [9, 18, 27, 36]

# 字典推导式
$ L = {x: y for x in range(1, 5) for y in range(6, 10) if y &gt; 8}
# {1: 9, 2: 9, 3: 9, 4: 9}

# 集合推导式
$ L = {x * y for x in range(1, 5) for y in range(6, 10) if y &gt; 8}
# set([9, 18, 27, 36])
</code></pre>

<h2 id="8-3-map-fliter-reduce函数">8.3 map &amp;&amp; fliter &amp;&amp; reduce函数</h2>

<p><strong>map函数</strong></p>

<p><code>map</code>为内置函数，用于遍历序列，然后将函数用于遍历过程中的每一个元素。函数定义：</p>

<pre><code>map(function, sequence[, sequence, ...]) -&gt; list
</code></pre>

<ul>
<li>function: 处理函数</li>
<li>sequence：一个或多个序列</li>
<li>返回值： list</li>
</ul>

<p>示例一(字符串也是一种序列)：</p>

<pre><code>&gt;&gt;&gt; map(ord, &quot;Hello World&quot;)
[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
</code></pre>

<p>利用上面的列表推导式也可以实现：</p>

<pre><code>&gt;&gt;&gt; [ ord(x) for x in &quot;Hello World&quot;]
[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
</code></pre>

<p>如果是多个序列，会同时将每个序列的元素拿出一起传给函数。如果长度不一致会用None补齐。</p>

<pre><code>&gt;&gt;&gt; map(lambda x, y :  (x, y) , &quot;Hello&quot;, &quot;Python&quot;)
[('H', 'P'), ('e', 'y'), ('l', 't'), ('l', 'h'), ('o', 'o'), (None, 'n')]
</code></pre>

<p><strong>filter函数</strong></p>

<p><code>filter</code>也为内置函数，将序列的每个元素传给<code>function</code>，然后将函数执行返回<code>True</code>的元素组成新的列表，<code>False</code>的元素则过滤掉。</p>

<pre><code>filter(function or None, sequence) -&gt; list, tuple, or string
</code></pre>

<p>如过滤掉字母<code>o</code></p>

<pre><code>&gt;&gt;&gt; filter(lambda x: x != &quot;o&quot;, &quot;Hello World&quot;)
'Hell Wrld'
</code></pre>

<p><strong>reduce函数</strong></p>

<p>reduce函数功能是将 sequence 中数据，按照 function 函数操作，如将列表第一个数与第二个数进行 function 操作，得到的结果和列表中下一个数据进行 function 操作，一直循环下去&hellip; py3以后使用，必须导入<code>from functools import reduce</code>.</p>

<pre><code>reduce(function, sequence[, initial]) -&gt; value
</code></pre>

<p>求4!</p>

<pre><code>&gt;&gt;&gt; reduce(lambda x,y : x*y, range(1,5))
24
</code></pre>

<h2 id="8-4-sort-sorted">8.4 sort &amp;&amp; sorted</h2>

<p><code>sort</code> 与 <code>sorted</code> 区别：<code>sort</code> 是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对所有可迭代的对象进行排序操作。</p>

<p><code>list</code> 的 <code>sort</code> 方法返回的是<strong>对已经存在的列表进行操作，无返回值</strong>，而内建函数 <code>sorted</code> 方法<strong>返回的是一个新的 list</strong>，而不是在原来的基础上进行的操作。</p>

<p>关键点：</p>

<ul>
<li><code>sort</code>改变原列表，<code>sorted</code>不会改变原列表</li>
<li><code>sort</code>只用于列表，<code>sorted</code>用于所有可迭代对象</li>
</ul>

<p><strong>sort</strong></p>

<pre><code>&gt;&gt;&gt; print(list.sort.__doc__)
L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
cmp(x, y) -&gt; -1, 0,
</code></pre>

<p>示例(具体参数使用参考<code>sorted</code>)：</p>

<pre><code>&gt;&gt;&gt; a = [1, 3, 2, 4]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[1, 2, 3, 4]
</code></pre>

<p><strong>sorted</strong></p>

<pre><code>&gt;&gt;&gt; print(sorted.__doc__)
sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list
</code></pre>

<p>参数说明：</p>

<ul>
<li>iterable &ndash; 可迭代对象。</li>
<li>cmp &ndash; 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li>
<li>key &ndash; 也是指定一个函数，cmp用来指定比较方法， key用来指定该用哪个key做比较</li>
<li>reverse &ndash; 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li>
</ul>

<p>示例一，指定cmp函数：</p>

<pre><code>def mycmp(x, y):
    print(x,y)
    if ord(x) &gt; ord(y):
        return 1
    elif ord(x) == ord(y):
        return 0
    else:
        return -1

a = &quot;b2a1c3&quot;

b = sorted(a, cmp=mycmp)

print(a, b)

# Output
# ('2', 'b')
# ('a', '2')
# ('a', 'b')
# ('a', '2')
# ('1', 'a')
# ('1', '2')
# ('c', 'a')
# ('c', 'b')
# ('3', 'a')
# ('3', '2')
# ('b2a1c3', ['1', '2', '3', 'a', 'b', 'c'])
</code></pre>

<p>示例二，指定key函数</p>

<pre><code>a = [{&quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 30}, {&quot;name&quot;: &quot;Peter&quot;, &quot;age&quot;: 18}, {&quot;name&quot;: &quot;Amy&quot;, &quot;age&quot;: 24}]

b = sorted(a, key=lambda x: x[&quot;age&quot;])

print(a)
print(b)


# [{'age': 30, 'name': 'Jack'}, {'age': 18, 'name': 'Peter'}, {'age': 24, 'name': 'Amy'}]
# [{'age': 18, 'name': 'Peter'}, {'age': 24, 'name': 'Amy'}, {'age': 30, 'name': 'Jack'}]
</code></pre>

<h2 id="8-5-zip函数">8.5 zip函数</h2>

<pre><code>zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]
</code></pre>

<p>zip()是 Python 的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回 list 的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p>

<pre><code>&gt;&gt;&gt; x = [&quot;a&quot;, &quot;b&quot;]
&gt;&gt;&gt; y = [1, 2]
&gt;&gt;&gt; t = zip(x, y)
&gt;&gt;&gt; t
[('a', 1), ('b', 2)]
&gt;&gt;&gt; zip(*t)
[('a', 'b'), (1, 2)]

-- 构建字典
&gt;&gt;&gt; dict(zip(x, y))
{'a': 1, 'b': 2}
</code></pre>

    <div class="eof">-- EOF --</div>
    <div class="eof_arrow">
        <a href="/"><img src="/static/img/arrow-back.png" style="width:25px;height:25px;" /></a>
    </div>
    
    <div class="eof_tag">
        最后更新于：
        <code style="border:0px;background:none;"><a href="/2019-12.html">2021-11-27 13:41</a></code>
    </div>
    
    <div class="eof_tag">
        发表于：
        <code style="border:0px;background:none;"><a href="/2019-12.html">2019-12-01 00:22</a></code>
    </div>
    <div class="eof_tag">
        标签：
        <code style="border:0px;background:none;"><a href="/tag/python.html">Python</a></code>
    </div>

    <div id="footer">
        <ul>
            <li>
            <b>上一篇</b>：<a href="/redis-cluster.html">Redis集群方案 - Cluster</a>
            </li>
            
            <li>
            <b>下一篇</b>：<a href="/redis-data-migration.html">Redis集群数据迁移</a>
            </li>
            <li>
                <b>Github地址</b>：<a href="https://github.com/pengbotao/itopic.go/blob/master/posts/python/Python入门知识点整理.md">https://github.com/pengbotao/itopic.go/blob/master/posts/python/Python入门知识点整理.md</a>
            <li>
            <li>
                @2013-2022 老彭的博客&nbsp;[Hosted by <a href="https://pages.github.com/" style="font-weight: bold" target="_blank">Github Pages</a>]
            </li>
        </ul>
    </div>
</div>
<div id="top"><a href="#"><img src="/static/img/arrow-top.png" style="width:40px;height:40px;" /></a></div>

<a href="https://github.com/pengbotao/itopic.go/blob/master/posts/python/Python入门知识点整理.md" target="_blank"  class="github-corner">
<svg width="60" height="60" viewBox="0 0 250 250" style="fill: #61687C; color:#fff; position: absolute;top: 0;border: 0;right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    </svg>
</a>
</body>
</html>